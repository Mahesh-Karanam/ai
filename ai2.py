# -*- coding: utf-8 -*-
"""AI2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ixJhmiwEx9f_pyH7Kg_QOn-rWBUXWH2
"""

def bfs(graph, start):
    open_list =[start]
    closed_list = set()
    print(list(open_list),'\t',list(closed_list))
    while open_list:
        current_node = open_list.pop(0)
        if current_node not in closed_list:
            #print(list(closed_list))
            closed_list.add(current_node)
            for neighbor in graph[current_node]:
                if neighbor not in closed_list and neighbor not in open_list:
                    open_list.append(neighbor)
        print(list(open_list),'\t',list(closed_list))
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

start_node = 'A'
bfs(graph, start_node)

def dfs(graph, start):
    open_list =[start]
    closed_list = set()
    print(list(open_list),'\t',list(closed_list))
    while open_list:
        current_node = open_list.pop()
        if current_node not in closed_list:
            #print(list(closed_list))
            closed_list.add(current_node)
            for neighbor in graph[current_node]:
                if neighbor not in closed_list and neighbor not in open_list:
                    open_list.append(neighbor)
        print(list(open_list),'\t',list(closed_list))
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

start_node = 'A'
dfs(graph, start_node)

import heapq

def ucs(graph, start):
    open_list = [(0, start)]
    closed_list = set()
    print(open_list,'\t',list(closed_list))
    while open_list:
        cost, current_node = heapq.heappop(open_list)
        if current_node not in closed_list:
            closed_list.add(current_node)
            for neighbor, edge_cost in graph[current_node].items():
                if neighbor not in closed_list and (edge_cost,neighbor) not in open_list:
                    heapq.heappush(open_list, (cost + edge_cost, neighbor))
        print(open_list,'\t',list(closed_list))

# Example adjacency list graph with weighted edges
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'D': 2, 'E': 5},
    'C': {'A': 4, 'F': 3},
    'D': {'B': 2},
    'E': {'B': 5, 'F': 6},
    'F': {'C': 3, 'E': 6}
}

start_node = 'A'
ucs(graph, start_node)

def iddfs(graph, start, goal):
    depth = 0
    while True:
        print("Depth Limit:", depth)
        open_list = [start]
        closed_list = set()
        result = dls(graph, start, goal, depth, open_list, closed_list)
        if result is not None:
            return result
        depth += 1

def dls(graph, node, goal, depth_limit, open_list, closed_list):
    if node == goal:
        print(open_list,'\t',list(closed_list))
        return node
    if depth_limit <= 0:
        print(open_list,'\t',list(closed_list))
        return None
    if depth_limit > 0:
        for neighbor in graph[node]:
            if neighbor not in closed_list and not in open_list:
                open_list.append(neighbor)
                result = dls(graph, neighbor, goal, depth_limit - 1, open_list, closed_list)
                if result is not None:
                    return result
                open_list.pop()
                closed_list.add(neighbor)
        print(open_list,'\t',list(closed_list))
        return None

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

start_node = 'A'
goal_node = 'F'
iddfs(graph, start_node, goal_node)

#WATER JUG USING BFS
# Function to pour water from one jug to another
def pour(jug, max_jug, target_jug):
    return max(0, jug - (max_jug - target_jug)), min(jug + target_jug, max_jug)
def valid_states(states,jug1_capacity,jug2_capacity):
  return [i for i in states if i[0]<= jug1_capacity and i[1] <= jug2_capacity]
# Function to perform BFS
def bfs(start, target, max_jug1, max_jug2):
    open_list = [start]
    closed_list = set()
    print(open_list,'\t',list(closed_list))
    while open_list:
        current_state = open_list.pop(0)
        jug1, jug2 = current_state
        if current_state == target:
            print("Target reached!")
            return

        closed_list.add(current_state)

        # Generate all possible states from the current state
        next_states = [
            pour(jug1, max_jug1, jug2),  # Pour from jug 1 to jug 2
            pour(jug2, max_jug2, jug1),  # Pour from jug 2 to jug 1
            (max_jug1, jug2),            # Fill jug 1
            (jug1, max_jug2),            # Fill jug 2
            (0, jug2),                   # Empty jug 1
            (jug1, 0)                    # Empty jug 2
        ]
        next_states=valid_states(next_states,max_jug1,max_jug2)
        # Add next states to open list if they are valid and not visited yet
        for state in list(set(next_states)):
            if state not in closed_list:
                open_list.append(state)
        print(open_list,'\t',list(closed_list))

# Example
start_state = (0, 0)  # Initial state of both jugs (jug1, jug2)
target_state = (3, 0)  # Target state (jug1, jug2)
max_jug1 = 5  # Maximum capacity of jug 1
max_jug2 = 3  # Maximum capacity of jug 2

bfs(start_state, target_state, max_jug1, max_jug2)

#WATER JUG USING DFS
# Function to pour water from one jug to another
def pour(jug, max_jug, target_jug):
    return max(0, jug - (max_jug - target_jug)), min(jug + target_jug, max_jug)
def valid_states(states,jug1_capacity,jug2_capacity):
  return [i for i in states if i[0]<= jug1_capacity and i[1] <= jug2_capacity]
# Function to perform BFS
def dfs(start, target, max_jug1, max_jug2):
    open_list = [start]
    closed_list = set()
    print(open_list,'\t',list(closed_list))
    while open_list:
        current_state = open_list.pop()

        jug1, jug2 = current_state

        if current_state == target:
            print("Target reached!")
            return

        closed_list.add(current_state)

        # Generate all possible states from the current state
        next_states = [
            pour(jug1, max_jug1, jug2),  # Pour from jug 1 to jug 2
            pour(jug2, max_jug2, jug1),  # Pour from jug 2 to jug 1
            (max_jug1, jug2),            # Fill jug 1
            (jug1, max_jug2),            # Fill jug 2
            (0, jug2),                   # Empty jug 1
            (jug1, 0)                    # Empty jug 2
        ]
        next_states=valid_states(next_states,max_jug1,max_jug2)
        # Add next states to open list if they are valid and not visited yet
        for state in list(set(next_states)):
            if state not in closed_list:
                open_list.append(state)
        print(open_list,'\t',list(closed_list))

# Example
start_state = (0, 0)  # Initial state of both jugs (jug1, jug2)
target_state = (3, 0)  # Target state (jug1, jug2)
max_jug1 = 5  # Maximum capacity of jug 1
max_jug2 = 3  # Maximum capacity of jug 2

dfs(start_state, target_state, max_jug1, max_jug2)